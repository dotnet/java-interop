<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="CecilResolver_XA0009" xml:space="preserve">
    <value>加载程序集“{0}”时出错。</value>
    <comment>{0} - File name</comment>
  </data>
  <data name="Generator_BG4000" xml:space="preserve">
    <value>无法删除旧常量: {0}。</value>
    <comment>{0} - The list of constants that could not be removed.
In this message, the term "constants" refers to class or interface members that have constant values.</comment>
  </data>
  <data name="Generator_BG4100" xml:space="preserve">
    <value>无法处理枚举映射。文本行: {0}。</value>
    <comment>{0} - The line that could not be processed.</comment>
  </data>
  <data name="Generator_BG4200" xml:space="preserve">
    <value>处理元数据修复期间出错: {0}。</value>
    <comment>{0} - The error encountered.</comment>
  </data>
  <data name="Generator_BG4300" xml:space="preserve">
    <value>XPath 规范无效: {0}。</value>
    <comment>{0} - The invalid XPath line.</comment>
  </data>
  <data name="Generator_BG4307" xml:space="preserve">
    <value>没有为路径 {0} 指定目标属性名称。</value>
    <comment>{0} - The invalid XPath line.</comment>
  </data>
  <data name="Generator_BG4400" xml:space="preserve">
    <value>意外的 “global::” 规范。例如，如果在 Metadata.xml 转换文件中指定了 “global::”，则会发生此错误。</value>
    <comment>The following are literal names and should not be translated: global::, Metadata.xml.</comment>
  </data>
  <data name="Generator_BG4500" xml:space="preserve">
    <value>“lang-features=default-interface-methods” 与 “codegen-target=xamarinandroid” 不兼容。</value>
    <comment>The following are literal command line arguments and should not be translated: 'lang-features=default-interface-methods', 'codegen-target=xamarinandroid'.</comment>
  </data>
  <data name="Generator_BG8101" xml:space="preserve">
    <value>意外的类子级 {0}。</value>
    <comment>{0} - The unexpected child class.</comment>
  </data>
  <data name="Generator_BG8102" xml:space="preserve">
    <value>类“{0}”具有未知的基类型“{1}”。</value>
    <comment>{0}, {1} - .NET types.</comment>
  </data>
  <data name="Generator_BG8103" xml:space="preserve">
    <value>类“{0}”具有无效的基类型“{1}”。</value>
    <comment>{0}, {1} - .NET types.</comment>
  </data>
  <data name="Generator_BG8200" xml:space="preserve">
    <value>无法分析程序集“{0}”: {1}。</value>
    <comment>{0} - Error .NET assembly.
{1} - The error encountered.</comment>
  </data>
  <data name="Generator_BG8300" xml:space="preserve">
    <value>对于构造函数“{0}”，找不到封闭类型“{1}”。</value>
    <comment>{0} - .NET constructor method.
{1} - .NET type.</comment>
  </data>
  <data name="Generator_BG8400" xml:space="preserve">
    <value>意外的字段类型 `{0}` ({1})。</value>
    <comment>{0} - .NET type.
{1} - .NET field signature.</comment>
  </data>
  <data name="Generator_BG8401_Method" xml:space="preserve">
    <value>由于方法名称重复，正在跳过“{0}.{1}”。(Java 类型:“{2}')</value>
    <comment>{0} - .NET type.
{1} - .NET field name.
{2} - Java type.</comment>
  </data>
  <data name="Generator_BG8401_NestedType" xml:space="preserve">
    <value>由于嵌套类型名称重复，正在跳过“{0}.{1}”。(Java 类型:“{2}')</value>
    <comment>{0} - .NET type.
{1} - .NET field name.
{2} - Java type.</comment>
  </data>
  <data name="Generator_BG8401_Property" xml:space="preserve">
    <value>由于字段或属性名称重复，正在跳过“{0}.{1}”。(Java 类型:“{2}”)</value>
    <comment>{0} - .NET type.
{1} - .NET field name.
{2} - Java type.</comment>
  </data>
  <data name="Generator_BG8402" xml:space="preserve">
    <value>由于字段重复，正在跳过“{0}.{1}”。(Java 类型:“{2}')</value>
    <comment>{0} - .NET type.
{1} - .NET field name.
{2} - Java type.</comment>
  </data>
  <data name="Generator_BG8403" xml:space="preserve">
    <value>类型“{0}”具有与封闭命名空间名称匹配的类型名称。有关详细信息，请参阅 https://aka.ms/BG8403。</value>
    <comment>{0} - Java type.</comment>
  </data>
  <data name="Generator_BG8500" xml:space="preserve">
    <value>“&lt;interface&gt;”的意外子元素:“{0}”。</value>
    <comment>{0} - XML element name.
&lt;interface&gt; should not be translated.</comment>
  </data>
  <data name="Generator_BG8501" xml:space="preserve">
    <value>“{0}.{1}”中未提供任何事件名称。</value>
    <comment>{0} - .NET type name
{1} - .NET member.</comment>
  </data>
  <data name="Generator_BG8502" xml:space="preserve">
    <value>正在使“{0}”及其所有嵌套类型失效，因为其某些接口无效。</value>
    <comment>{0} - .NET type name.</comment>
  </data>
  <data name="Generator_BG8503" xml:space="preserve">
    <value>正在使“{0}”及其所有嵌套类型失效，因为其某些方法无效。</value>
    <comment>{0} - .NET type name.</comment>
  </data>
  <data name="Generator_BG8504" xml:space="preserve">
    <value>“{0}.{1}”的事件名称无效。可以通过将规则添加到 Metadata.xml 转换文件来分配有效的 “eventName” 或 “argsType”。</value>
    <comment>{0} - .NET type name
{1} - .NET member.
The following terms should not be translated: eventName, argsType, Metadata.xml.</comment>
  </data>
  <data name="Generator_BG8506" xml:space="preserve">
    <value>“{0}.{1}”的事件属性名称无效。可以通过将规则添加到 Metadata.xml 转换文件来分配有效的 “eventName” 或 “argsType”。</value>
    <comment>{0} - .NET type name
{1} - .NET member.
The following terms should not be translated: eventName, argsType, Metadata.xml.</comment>
  </data>
  <data name="Generator_BG8600" xml:space="preserve">
    <value>XML 文件“{0}”无效: {1}。</value>
    <comment>{0} - File name
{1} - The error encountered.</comment>
  </data>
  <data name="Generator_BG8601" xml:space="preserve">
    <value>找不到“&lt;package&gt;”元素。</value>
    <comment>The following terms should not be translated: &lt;package&gt;.</comment>
  </data>
  <data name="Generator_BG8602" xml:space="preserve">
    <value>意外的根子节点:“&lt;{0}&gt;”。</value>
    <comment>{0} - XML element name.</comment>
  </data>
  <data name="Generator_BG8603" xml:space="preserve">
    <value>意外的“&lt;package&gt;”子节点:“&lt;{0}&gt;”。</value>
    <comment>{0} - XML element name.
The following terms should not be translated: &lt;package&gt;.</comment>
  </data>
  <data name="Generator_BG8604" xml:space="preserve">
    <value>找不到嵌套类型“{1}”的顶级上级类型“{0}”。</value>
    <comment>{0}, {1} - .NET types.</comment>
  </data>
  <data name="Generator_BG8605" xml:space="preserve">
    <value>找不到 Java 类型“{0}”(是否缺少 Java 引用 jar/aar 或 Java 绑定库 NuGet?)</value>
    <comment>{0} - Java type.</comment>
  </data>
  <data name="Generator_BG8606" xml:space="preserve">
    <value>无法绑定某些类型或成员，因为找不到引用的 Java 类型。有关详细信息，请参阅 “java-resolution-report.log” 文件。</value>
    <comment>The following terms should not be translated: java-resolution-report.log</comment>
  </data>
  <data name="Generator_BG8700" xml:space="preserve">
    <value>成员“{1}”的返回类型“{0}”未知。</value>
    <comment>{0} - Java type.
{1} - .NET member.</comment>
  </data>
  <data name="Generator_BG8701" xml:space="preserve">
    <value>成员“{1}”的返回类型“{0}”无效。</value>
    <comment>{0} - Java type.
{1} - .NET member.</comment>
  </data>
  <data name="Generator_BG8800" xml:space="preserve">
    <value>成员“{1}”的参数类型“{0}”未知。</value>
    <comment>{0} - Java type.
{1} - .NET member.</comment>
  </data>
  <data name="Generator_BG8801" xml:space="preserve">
    <value>成员“{1}”的参数类型“{0}”无效。</value>
    <comment>{0} - Java type.
{1} - .NET member.</comment>
  </data>
  <data name="Generator_BG8A00" xml:space="preserve">
    <value>Metadata.xml 元素“{0}”不匹配任何节点。</value>
    <comment>{0} - XML transform. (example: '&lt;remove-node path="/api/package[@name='javax.sql']"')
The following terms should not be translated: Metadata.xml.</comment>
  </data>
  <data name="Generator_BG8A07" xml:space="preserve">
    <value>命名空间转换“{0}”无效</value>
    <comment>{0} - XML transform. (example: '&lt;ns-replace source="example" replacement="Example" /&gt;')</comment>
  </data>
  <data name="Generator_BG8A08" xml:space="preserve">
    <value>Metadata.xml 元素 "{0}" 缺少 "path" 属性。</value>
    <comment>{0} - XML transform. (example: '&lt;remove-node path="/api/package[@name='javax.sql']"')
The following terms should not be translated: Metadata.xml, path.</comment>
  </data>
  <data name="Generator_BG8B00" xml:space="preserve">
    <value>成员“{1}”的泛型参数约束类型“{0}”未知。</value>
    <comment>{0} - .NET type name
{1} - .NET member.</comment>
  </data>
  <data name="Generator_BG8C00" xml:space="preserve">
    <value>找不到类型“{0}”的基接口“{1}”。</value>
    <comment>{0}, {1} - .NET types.</comment>
  </data>
  <data name="Generator_BG8C01" xml:space="preserve">
    <value>对于类型“{0}”，基接口“{1}”无效。</value>
    <comment>{0}, {1} - .NET types.</comment>
  </data>
  <data name="JavaCallableWrappers_XA4200" xml:space="preserve">
    <value>无法为类型“{0}”生成 Java 包装器。仅支持 “class” 类型。</value>
    <comment>{0} - Java type.
The following terms should not be translated:
class.</comment>
  </data>
  <data name="JavaCallableWrappers_XA4201" xml:space="preserve">
    <value>无法确定类型“{0}”的 JNI 名称。</value>
    <comment>{0} - Java type.
The following terms should not be translated: JNI.</comment>
  </data>
  <data name="JavaCallableWrappers_XA4203" xml:space="preserve">
    <value>“Name” 属性必须是完全限定的类型，如 “com.example.MyClass”，并且找不到“{0}”的包。</value>
    <comment>{0} - Java type.
The following terms should not be translated:
Name, com.example.MyClass.</comment>
  </data>
  <data name="JavaCallableWrappers_XA4204" xml:space="preserve">
    <value>无法解析接口类型“{0}”。是否缺少程序集引用?</value>
    <comment>{0} - Java interface.</comment>
  </data>
  <data name="JavaCallableWrappers_XA4205" xml:space="preserve">
    <value>[ExportField] 只能用于具有 0 个参数的方法。</value>
    <comment>The following terms should not be translated: [ExportField].</comment>
  </data>
  <data name="JavaCallableWrappers_XA4206" xml:space="preserve">
    <value>[Export] 不能用于泛型类型。</value>
    <comment>The following terms should not be translated: [Export].</comment>
  </data>
  <data name="JavaCallableWrappers_XA4207" xml:space="preserve">
    <value>[ExportField] 不能用于泛型类型。</value>
    <comment>The following terms should not be translated: [ExportField].</comment>
  </data>
  <data name="JavaCallableWrappers_XA4208" xml:space="preserve">
    <value>[ExportField] 不能用于返回 “void” 的方法。</value>
    <comment>The following terms should not be translated: [ExportField], void.</comment>
  </data>
  <data name="JavaCallableWrappers_XA4217" xml:space="preserve">
    <value>无法替代 Kotlin 生成的方法“{0}”，因为它不是有效的 Java 方法名称。只能从 Kotlin 替代此方法。</value>
    <comment>{0} - Kotlin method name.</comment>
  </data>
  <data name="JniMarshalMethodGen_JM4001" xml:space="preserve">
    <value>无法预加载引用“{0}”。</value>
    <comment>{0} - assembly path</comment>
  </data>
  <data name="JniMarshalMethodGen_JM4002" xml:space="preserve">
    <value>请至少指定一个要处理的程序集。</value>
    <comment>The following terms should not be translated or have any capitalization changes: ASSEMBLY. This is a special case for this particular message. In most messages, "assembly" would be translated.</comment>
  </data>
  <data name="JniMarshalMethodGen_JM4003" xml:space="preserve">
    <value>无法创建 Java VM{0}{1}</value>
    <comment>{0} - newline, {1} - exception</comment>
  </data>
  <data name="JniMarshalMethodGen_JM4004" xml:space="preserve">
    <value>无法读取配置文件“{0}”。{1}{2}</value>
    <comment>{0} - path, {1} - newline, {2} - exception. In this message, the term "profile" refers to a customized list of types to process.</comment>
  </data>
  <data name="JniMarshalMethodGen_JM4005" xml:space="preserve">
    <value>路径“{0}”不存在。</value>
    <comment>{0} - path</comment>
  </data>
  <data name="JniMarshalMethodGen_JM4006" xml:space="preserve">
    <value>无法处理程序集“{0}”{1}{2}{1}{3}</value>
    <comment>{0} - assembly, {1} - newline, {2} - exception message, {3} exception</comment>
  </data>
  <data name="JniMarshalMethodGen_JM8001" xml:space="preserve">
    <value>找不到接口 {0}</value>
    <comment>{0} - interface name</comment>
  </data>
  <data name="JniMarshalMethodGen_JM8003" xml:space="preserve">
    <value>加载类型时捕获到异常。将不处理无法加载的类型。请确保使用 -r 选项提供这些类型所需的任何其他程序集引用。异常:{0}{1}</value>
    <comment>{0} - newline, {1} - exception. The following terms should not be translated: -r</comment>
  </data>
  <data name="JniMarshalMethodGen_JM8004" xml:space="preserve">
    <value>找不到类型“{0}”。将不会处理该类型。确保使用 -L 选项提供所有引用的程序集的目录。</value>
    <comment>{0} - type
The following terms should not be translated: -L</comment>
  </data>
  <data name="JniMarshalMethodGen_JM8005" xml:space="preserve">
    <value>封送方法类型“{0}”已存在。已跳过程序集“{1}”中封送方法的生成。在需要时使用 -f 强制重新生成。</value>
    <comment>{0} - type, {1} - assembly name. The following terms should not be translated: -f. In this message, the term "marshal methods" refers to methods that allow interaction between the managed methods and Java methods, similar to the methods of the .NET System.Runtime.InteropServices.Marshal class.</comment>
  </data>
  <data name="JniMarshalMethodGen_JM8006" xml:space="preserve">
    <value>在程序集元数据中找不到方法“{0}”的定义。将不会处理它。确保使用 -L 选项提供所有引用的程序集的目录。</value>
    <comment>{0} - method
The following terms should not be translated: -L</comment>
  </data>
  <data name="JniMarshalMethodGen_JM8007" xml:space="preserve">
    <value>找不到 System.Console.WriteLine() 方法。正在禁用调试注入。要启用调试注入，请确保使用 -L 选项提供包含 mscorlib 的目录。</value>
    <comment>The following terms should not be translated: -L</comment>
  </data>
</root>