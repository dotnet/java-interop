#nullable enable

using System;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.Serialization;
using System.Text;

namespace Java.Interop {

	[JniTypeSignature (JniTypeName)]
	/* static */ sealed class ManagedPeer : JavaObject {

		internal const string JniTypeName = "net/dot/jni/ManagedPeer";


		static  readonly    JniPeerMembers  _members        = new JniPeerMembers (JniTypeName, typeof (ManagedPeer));

		static ManagedPeer ()
		{
			_members.JniPeerType.RegisterNativeMethods (
					new JniNativeMethodRegistration (
						"construct",
						ConstructSignature,
						new ConstructMarshalMethod (Construct)),
					new JniNativeMethodRegistration (
						"registerNativeMembers",
						RegisterNativeMembersSignature,
						new RegisterMarshalMethod (RegisterNativeMembers))
			);
		}

		ManagedPeer ()
		{
		}

		internal static void Init ()
		{
			// Present so that JniRuntime has _something_ to reference to
			// prompt invocation of the static constructor & registration
		}

		public override JniPeerMembers JniPeerMembers {
			get {return _members;}
		}

		const string ConstructSignature = "(Ljava/lang/Object;Ljava/lang/String;[Ljava/lang/Object;)V";

		// TODO: Keep in sync with the code generated by ExportedMemberBuilder
		delegate void ConstructMarshalMethod (IntPtr jnienv,
				IntPtr klass,
				IntPtr n_self,
				IntPtr n_constructorSignature,
				IntPtr n_constructorArguments);
		static void Construct (
				IntPtr jnienv,
				IntPtr klass,
				IntPtr n_self,
				IntPtr n_constructorSignature,
				IntPtr n_constructorArguments)
		{
			var envp = new JniTransition (jnienv);
			try {
				var runtime = JniEnvironment.Runtime;
				var r_self  = new JniObjectReference (n_self);
				var self    = runtime.ValueManager.PeekPeer (r_self);
				if (self != null) {
					var state   = self.JniManagedPeerState;
					if ((state & JniManagedPeerStates.Activatable) != JniManagedPeerStates.Activatable &&
							(state & JniManagedPeerStates.Replaceable) != JniManagedPeerStates.Replaceable) {
						return;
					}
				}

				if (JniEnvironment.WithinNewObjectScope) {
					if (runtime.ObjectReferenceManager.LogGlobalReferenceMessages) {
						runtime.ObjectReferenceManager.WriteGlobalReferenceLine (
								"Warning: Skipping managed constructor invocation for PeerReference={0} IdentityHashCode=0x{1} Java.Type={2}. " +
								"Please use JniPeerMembers.InstanceMethods.StartCreateInstance() + JniPeerMembers.InstanceMethods.FinishCreateInstance() instead of " +
								"JniEnvironment.Object.NewObject().",
								r_self,
								runtime.ValueManager.GetJniIdentityHashCode (r_self).ToString ("x"),
								JniEnvironment.Types.GetJniTypeNameFromInstance (r_self));
					}
					return;
				}

				var typeSig = new JniTypeSignature (JniEnvironment.Types.GetJniTypeNameFromInstance (r_self));
				var type    = GetTypeFromSignature (runtime.TypeManager, typeSig);

				if (type.IsGenericTypeDefinition) {
					throw new NotSupportedException (
							"Constructing instances of generic types from Java is not supported, as the type parameters cannot be determined.",
							CreateJniLocationException ());
				}

				var ptypes  = GetParameterTypes (runtime.TypeManager, JniEnvironment.Strings.ToString (n_constructorSignature));
				var pvalues = GetValues (runtime, new JniObjectReference (n_constructorArguments), ptypes);
				var cinfo = type.GetConstructor (ptypes);
				if (cinfo == null) {
					throw CreateMissingConstructorException (type, ptypes);
				}

				if (self != null) {
					cinfo.Invoke (self, pvalues);
					return;
				}

				JniEnvironment.Runtime.ValueManager.ActivatePeer (self, new JniObjectReference (n_self), cinfo, pvalues);
			}
			catch (Exception e) when (JniEnvironment.Runtime.ExceptionShouldTransitionToJni (e)) {
				envp.SetPendingException (e);
			}
			finally {
				envp.Dispose ();
			}
		}

		static Exception CreateMissingConstructorException (Type type, Type [] ptypes)
		{
			var message = new StringBuilder ();
			message.Append ("Unable to find constructor ");
			message.Append (type.FullName);
			message.Append ("(");

			if (ptypes.Length > 0) {
				message.Append (ptypes [0].FullName);
				for (int i = 1; i < ptypes.Length; ++i)
					message.Append (", ").Append (ptypes [i].FullName);
			}

			message.Append (")");
			message.Append (". Please provide the missing constructor.");

			return new NotSupportedException (message.ToString (), CreateJniLocationException ());
		}


		static Exception CreateJniLocationException ()
		{
			using (var e = new JavaException ()) {
				return new JniLocationException (e.ToString ());
			}
		}

		static Type[] GetParameterTypes (JniRuntime.JniTypeManager typeMgr, string? signature)
		{
			if (string.IsNullOrEmpty (signature))
				return Array.Empty<Type> ();
			var ptypes      = new Type [JniMemberSignature.GetParameterCountFromMethodSignature (signature)];
			int i           = 0;
			foreach (var jniType in JniMemberSignature.GetParameterTypesFromMethodSignature (signature)) {
				ptypes [i++]    = GetTypeFromSignature (typeMgr, jniType, signature);
			}
			return ptypes;
		}

		static object?[]? GetValues (JniRuntime runtime, JniObjectReference values, Type[] types)
		{
			if (!values.IsValid)
				return null;

			int len = JniEnvironment.Arrays.GetArrayLength (values);
			Debug.Assert (len == types.Length,
					string.Format ("Unexpected number of parameter types! Expected {0}, got {1}", types.Length, len));
			var pvalues = new object? [types.Length];
			for (int i = 0; i < pvalues.Length; ++i) {
				var n_value = JniEnvironment.Arrays.GetObjectArrayElement (values, i);
				var value   = runtime.ValueManager.GetValue (ref n_value, JniObjectReferenceOptions.CopyAndDispose, types [i]);
				pvalues [i] = value;
			}

			return pvalues;
		}

		const   string  RegisterNativeMembersSignature  = "(Ljava/lang/Class;Ljava/lang/String;)V";

		delegate void RegisterMarshalMethod (IntPtr jnienv,
				IntPtr klass,
				IntPtr n_nativeClass,
				IntPtr n_methods);
		static unsafe void RegisterNativeMembers (
				IntPtr jnienv,
				IntPtr klass,
				IntPtr n_nativeClass,
				IntPtr n_methods)
		{
			var envp = new JniTransition (jnienv);
			try {
				var r_nativeClass   = new JniObjectReference (n_nativeClass);
#pragma warning disable CA2000
				var nativeClass     = new JniType (ref r_nativeClass, JniObjectReferenceOptions.Copy);
#pragma warning restore CA2000

				var methodsRef              = new JniObjectReference (n_methods);

				var typeSig                 = new JniTypeSignature (nativeClass.Name);
				var type                    = GetTypeFromSignature (JniEnvironment.Runtime.TypeManager, typeSig);

#if NET
				int methodsLength           = JniEnvironment.Strings.GetStringLength (methodsRef);
				var methodsChars            = JniEnvironment.Strings.GetStringChars (methodsRef, null);
				var methods                 = new ReadOnlySpan<char>(methodsChars, methodsLength);
				try {
					JniEnvironment.Runtime.TypeManager.RegisterNativeMembers (nativeClass, type, methods);
				}
				finally {
					JniEnvironment.Strings.ReleaseStringChars (methodsRef, methodsChars);
				}
#else   // NET
				var methods                 = JniEnvironment.Strings.ToString (methodsRef);
				JniEnvironment.Runtime.TypeManager.RegisterNativeMembers (nativeClass, type, methods);
#endif  // NET

			}
			catch (Exception e) when (JniEnvironment.Runtime.ExceptionShouldTransitionToJni (e)) {
				Debug.WriteLine ($"Exception when trying to register native methods with JNI: {e}");
				envp.SetPendingException (e);
			}
			finally {
				envp.Dispose ();
			}
		}

		[return: DynamicallyAccessedMembers (DynamicallyAccessedMemberTypes.PublicConstructors | DynamicallyAccessedMemberTypes.NonPublicConstructors)]
		static Type GetTypeFromSignature (JniRuntime.JniTypeManager typeManager, JniTypeSignature typeSignature, string? context = null)
		{
			return typeManager.GetType (typeSignature) ??
				throw new NotSupportedException ($"Could not find System.Type corresponding to Java type {typeSignature} {(context == null ? "" : "within `" + context + "`")}.");
		}
	}

	sealed class JniLocationException : Exception {

		string stackTrace;

		public JniLocationException (string stackTrace)
		{
			this.stackTrace = stackTrace;
		}

		public override string StackTrace {
			get {
				return stackTrace;
			}
		}
	}
}

