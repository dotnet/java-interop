using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Xml;
using System.Xml.Linq;
using Sgml;

namespace Xamarin.Android.ApiTools.DroidDocImporter
{

	class HtmlLoader
	{
		// okay, SgmlReader itself has something similar, but I need something that makes sure to resolve only embedded resources.
		class EmbeddedResourceEntityResolver : Sgml.IEntityResolver
		{
			public IEntityContent GetContent (Uri uri)
			{
				return new EmbeddedResourceEntityContent (uri.LocalPath);
			}

			class EmbeddedResourceEntityContent : Sgml.IEntityContent
			{
				public EmbeddedResourceEntityContent (string name)
				{
					if (name == null)
						throw new ArgumentNullException (nameof (name));
					this.name = Path.GetFileName (name);
				}

				string name;

				public Encoding Encoding {
					get { return Encoding.UTF8; }
				}

				public string MimeType {
					get { return "text/plain"; }
				}

				public Uri Redirect {
					get { return new Uri ("file:///" + this.name); }
				}

				public Stream Open ()
				{
					return typeof (HtmlLoader).Assembly.GetManifestResourceStream (name);
				}
			}
		}

		enum JavaDocKind
		{
			DroidDoc,
			DroidDoc2,
			Java6,
			Java7,
			Java8
		}

		Sgml.SgmlDtd HtmlDtd;

		public HtmlLoader ()
		{
			HtmlDtd = LoadHtmlDtd ();
		}

		Sgml.SgmlDtd LoadHtmlDtd ()
		{
			return Sgml.SgmlDtd.Parse (new Uri ("file:///"),
						      "HTML",
						      "-//W3C//DTD HTML 4.01//EN",
			                              "file:///strict.dtd",
						      string.Empty, new NameTable (), new EmbeddedResourceEntityResolver ());
		}

		public XElement GetJavaDocFile (string path)
		{
			JavaDocKind kind;
			return GetJavaDocFile (path, out kind);
		}

		XElement GetJavaDocFile (string path, out JavaDocKind kind)
		{
			kind = JavaDocKind.DroidDoc;
			string rawHTML = ReadAndSanitizeHtmlFile (path);
			if (rawHTML.Substring (0, 500).IndexOf ("Generated by javadoc (build 1.6", StringComparison.Ordinal) > 0)
				kind = JavaDocKind.Java6;
			if (rawHTML.Substring (0, 500).IndexOf ("Generated by javadoc (version 1.7", StringComparison.Ordinal) > 0)
				kind = JavaDocKind.Java7;
			if (rawHTML.Substring (0, 500).IndexOf ("Generated by javadoc (1.8", StringComparison.Ordinal) > 0)
				kind = JavaDocKind.Java8;
			var html = new Sgml.SgmlReader () {
				InputStream = new StringReader (rawHTML),
				CaseFolding = Sgml.CaseFolding.ToLower,
				Dtd = HtmlDtd
			};
			var doc = XDocument.Load (html, LoadOptions.SetLineInfo | LoadOptions.SetBaseUri);
			return doc.Root;
		}

		string ReadAndSanitizeHtmlFile (string path)
		{
			var info = new FileInfo (path);
			var contents = new StringBuilder (checked((int)info.Length));
			bool veryFirstChar = true;
			bool in_tag = false;
			char in_quote = '\0';
			using (var r = info.OpenText ()) {

				int ch;
				while ((ch = r.Read ()) >= 0) {
					if (ch == '<') {
						// Some of the HTML files are invalid, containing constructs such as
						// 'foo <0', which should be 'foo &lt;0'.
						// There are also <?> which needs to be replaced by &lt;?>.
						//
						// We check the next char to '<' so that those with only valid NCName are treated as start tag.
						char next = (char)r.Peek ();
						if (!in_tag && (next == '/' || next == '!' || XmlConvert.IsStartNCNameChar (next))) {
							in_tag = true;
							contents.Append ('<');
						} else {
							contents.Append ("&lt;");
						}
					} else if (ch == '>' && in_tag) {
						if (in_quote != '\0')
							contents.Append ("&gt;");
						else {
							in_tag = false;
							contents.Append ('>');
						}
					} else if (in_tag && (ch == '"' || ch == '\'')) {
						if (in_quote == ch)
							in_quote = '\0';
						else if (in_quote == '\0')
							in_quote = (char) ch;
						contents.Append ((char) ch);
					} else if (ch == '&') {
						var b = new List<char> ();
						while ((ch = r.Read ()) >= 0 && ch != ';' && ch != ' ') // sometimes the input HTML contains '&' as a standalone character (i.e. Google emits invalid HTML... android/support/test/espresso/idling/CountingIdlingResource.html has that problem.)
							b.Add ((char)ch);
						var entity = new string (b.ToArray ());
						switch (entity) {
						case "#124":
							contents.Append ("|");
							break;
						case "#160":
						case "#xA0":
						case "nbsp":
							contents.Append ("\u00A0");
							break;
						case "8211":
							contents.Append ("\u2011");
							break;
						default:
							contents.Append ("&").Append (entity).Append (";");
							break;
						}
					} else if (ch == '\0')
						contents.Append ("NUL");
					else
						contents.Append ((char)ch);
					if (veryFirstChar)
						veryFirstChar = false;
				}
			}

			var firstPass = contents.ToString ();
			contents.Clear ();
			int open_count = 0;
			bool in_quot = false, in_apos = false;
			foreach (char ch in firstPass) {
				if (ch == '"' && open_count > 0) {
					if (in_quot)
						open_count = 1; // reset. Something like <... ...="...<..." (without '>') happened
					in_quot = !in_quot;
				}
				if (ch == '\'' && open_count > 0) {
					if (in_quot)
						open_count = 1; // reset. Something like <... ...='...<...' (without '>') happened
					in_apos = !in_apos;
				}

				if (ch == '<') {
					if (open_count > 0)
						contents.Append ("&lt;");
					else
						contents.Append ((char)ch);
					open_count++;
				} else if (ch == '>') {
					if (open_count > 0)
						open_count--;
					if (open_count > 0)
						contents.Append ("&gt;");
					else
						contents.Append ((char)ch);
				} else
					contents.Append ((char)ch);
			}

			// In some documents (e.g. java/util/prefs/Preferences.html) there are invalid !DOCTYPE in the middle, which breaks SgmlReader. Kill them.
			contents.Replace ("<!DOCTYPE", "&lt;!DOCTYPE", 10, contents.Length - 10);

			// FIXME: this should not be required, but Java.Util.Concurrent.ThreadPoolExecutor fails by invalid PI.
			return contents.Replace ("<?>", "&lt;?&gt;").ToString ();
		}
	}
}
